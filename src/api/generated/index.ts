/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import type {
  BodyUploadFileMeGraphsGraphIdUploadFilePost,
  GenerateQuestionsRequest,
  GraphContentResponse,
  GraphEnrollmentResponse,
  GraphVisualization,
  KnowledgeGraphCreate,
  KnowledgeGraphResponse,
  KnowledgeNodeCreate,
  KnowledgeNodeResponse,
  NextQuestionResponse,
  PrerequisiteCreate,
  PrerequisiteResponse,
  QuestionCreateForGraph,
  QuestionResponseFromGraph,
  RelationGenerationResponse,
  SingleAnswerSubmitRequest,
  SingleAnswerSubmitResponse,
  UserRead
} from './model';

import { apiClient } from '../http';
type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];


  export const getFastAPI = () => {
/**
 * @summary Read Users Me
 */
const readUsersMeUsersMeGet = (
    
 options?: SecondParameter<typeof apiClient<UserRead>>,) => {
      return apiClient<UserRead>(
      {url: `/users/me`, method: 'GET'
    },
      options);
    }
  
/**
 * Get the next recommended question for your own knowledge graph.

This endpoint is for graph owners to practice on their own graphs (including private ones).
For enrolled users practicing public/template graphs, use GET /graphs/{graph_id}/next-question.

Uses hybrid BKT + FSRS algorithm for intelligent question selection:

**Algorithm Flow:**
1. **Phase 1 (FSRS Filtering)**: Find nodes due for review (due_date <= today)
2. **Phase 2 (BKT Sorting)**: Order by prerequisites, level, mastery, impact
3. **Phase 3 (New Learning)**: If no reviews due, find new content

**Selection Priority:**
- Prerequisites over dependents (master foundations first)
- Lower knowledge level (foundational concepts first)
- Weaker mastery (strengthen weak areas)
- Higher impact (unlock more content)
- More overdue (don't let reviews slip)

Args:
    graph_id: Knowledge graph UUID
    db: Database session
    current_user: Authenticated user (must be the graph owner)

Returns:
    NextQuestionResponse containing the recommended question and metadata

Raises:
    HTTPException 403: User is not the owner of this graph
    HTTPException 404: Knowledge graph not found
    HTTPException 500: Recommendation service error
 * @summary Get next recommended question for your own graph
 */
const getNextQuestionMeGraphsGraphIdNextQuestionGet = (
    graphId: string,
 options?: SecondParameter<typeof apiClient<NextQuestionResponse>>,) => {
      return apiClient<NextQuestionResponse>(
      {url: `/me/graphs/${graphId}/next-question`, method: 'GET'
    },
      options);
    }
  
/**
 * Create a new knowledge node in a specific knowledge graph.

Only the owner of the graph can create nodes in it.

Args:
    graph_id: UUID of the knowledge graph
    node_data: Node creation data (node_id, node_name, description)
    db: Database session
    current_user: Authenticated user

Returns:
    KnowledgeNodeResponse: The created knowledge node

Raises:
    404: Graph not found
    403: User is not the owner of the graph
    409: Node with the same node_id already exists in this graph
 * @summary Create a new knowledge node in a graph
 */
const createKnowledgeNodeNewMeGraphsGraphIdNodesPost = (
    graphId: string,
    knowledgeNodeCreate: KnowledgeNodeCreate,
 options?: SecondParameter<typeof apiClient<KnowledgeNodeResponse>>,) => {
      return apiClient<KnowledgeNodeResponse>(
      {url: `/me/graphs/${graphId}/nodes`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: knowledgeNodeCreate
    },
      options);
    }
  
/**
 * Create a prerequisite relationship between two nodes in a graph.

Structure: (from_node) IS_PREREQUISITE_FOR (to_node)
Meaning: from_node must be learned before to_node.

IMPORTANT CONSTRAINT: Only leaf nodes can have prerequisite relationships.
This ensures precise diagnosis of student knowledge gaps at the atomic knowledge level.

Only the owner of the graph can create prerequisites.

Args:
    graph_id: UUID of the knowledge graph
    prereq_data: Prerequisite data (from_node_id, to_node_id, weight)
    db: Database session
    current_user: Authenticated user

Returns:
    PrerequisiteResponse: The created prerequisite relationship

Raises:
    400: One or both nodes are not leaf nodes
    404: Graph not found or one of the nodes not found
    403: User is not the owner of the graph
    409: Prerequisite already exists
 * @summary Create a prerequisite relationship
 */
const createPrerequisiteNewMeGraphsGraphIdPrerequisitesPost = (
    graphId: string,
    prerequisiteCreate: PrerequisiteCreate,
 options?: SecondParameter<typeof apiClient<PrerequisiteResponse>>,) => {
      return apiClient<PrerequisiteResponse>(
      {url: `/me/graphs/${graphId}/prerequisites`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: prerequisiteCreate
    },
      options);
    }
  
/**
 * Create a new question for a knowledge node in a graph.

Questions are assessment items used to test user mastery of a node.
The details field structure depends on question_type:
- Multiple Choice: {"question_type": "multiple_choice", "options": [...], "correct_answer": int, "p_g": float, "p_s": float}
- Fill in Blank: {"question_type": "fill_in_the_blank", "expected_answer": [...], "p_g": float, "p_s": float}
- Calculation: {"question_type": "calculation", "expected_answer": [...], "precision": int, "p_g": float, "p_s": float}

Design Note:
    - question_type is stored both as a top-level field AND within details:
      * Top-level: Stored in database column for efficient SQL filtering
      * Within details: Required for Pydantic discriminated union validation
    - p_g (guess probability) and p_s (slip probability) are stored only in details JSONB

Only the owner of the graph can create questions.

Args:
    graph_id: UUID of the knowledge graph
    question_data: Question data with typed details (including question_type, p_g, and p_s)
    db: Database session
    current_user: Authenticated user

Returns:
    QuestionResponseFromGraph: The created question

Raises:
    400: Invalid graph_id format
    404: Graph not found or node not found
    403: User is not the owner of the graph
 * @summary Create a new question for a knowledge node
 */
const createQuestionNewMeGraphsGraphIdQuestionsPost = (
    graphId: string,
    questionCreateForGraph: QuestionCreateForGraph,
 options?: SecondParameter<typeof apiClient<QuestionResponseFromGraph>>,) => {
      return apiClient<QuestionResponseFromGraph>(
      {url: `/me/graphs/${graphId}/questions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: questionCreateForGraph
    },
      options);
    }
  
/**
 * Get all knowledge graphs owned by the authenticated user.

Returns:
    list[KnowledgeGraphResponse]: List of all knowledge graphs owned by the user,
        ordered by creation date (newest first). Each graph includes:
        - Basic graph information (name, description, tags, etc.)
        - node_count: Number of knowledge nodes in the graph
 * @summary Get all knowledge graphs owned by the current user
 */
const getMyGraphsMeGraphsGet = (
    
 options?: SecondParameter<typeof apiClient<KnowledgeGraphResponse[]>>,) => {
      return apiClient<KnowledgeGraphResponse[]>(
      {url: `/me/graphs/`, method: 'GET'
    },
      options);
    }
  
/**
 * Create a new knowledge graph for the authenticated user.

This endpoint allows an authenticated user to create a new knowledge graph.
The owner_id is automatically set to the current user from the JWT token.
The slug is automatically generated from the name.

Args:
    graph_data (KnowledgeGraphCreate): The data for the new graph,
        including name, description, tags, and is_public flag.
    db_session (AsyncSession): The database session dependency.
    current_user (User): The authenticated user from JWT token.

Raises:
    HTTPException (status.HTTP_409_CONFLICT): If a knowledge graph
        with the same slug already exists for this user.
    HTTPException (status.HTTP_500_INTERNAL_SERVER_ERROR): If the database
        commit fails or any other unexpected error occurs.

Returns:
    KnowledgeGraph: The newly created knowledge graph with generated id and slug.
 * @summary Create knowledge graph
 */
const createGraphMeGraphsPost = (
    knowledgeGraphCreate: KnowledgeGraphCreate,
 options?: SecondParameter<typeof apiClient<KnowledgeGraphResponse>>,) => {
      return apiClient<KnowledgeGraphResponse>(
      {url: `/me/graphs/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: knowledgeGraphCreate
    },
      options);
    }
  
/**
 * Get a specific knowledge graph owned by the authenticated user.

Args:
    knowledge_graph: Owned knowledge graph (injected by get_owned_graph dependency)
    db_session: Database session
    current_user: Authenticated user

Returns:
    KnowledgeGraphResponse: Graph details including node count

Raises:
    HTTPException 404: If the knowledge graph doesn't exist
    HTTPException 403: If the user is not the owner
 * @summary Get a specific knowledge graph owned by the current user
 */
const getMyGraphMeGraphsGraphIdGet = (
    graphId: string,
 options?: SecondParameter<typeof apiClient<KnowledgeGraphResponse>>,) => {
      return apiClient<KnowledgeGraphResponse>(
      {url: `/me/graphs/${graphId}`, method: 'GET'
    },
      options);
    }
  
/**
 * Get visualization data for a knowledge graph you own.

Returns all nodes with mastery scores and all edges for rendering.

Args:
    knowledge_graph: Owned knowledge graph (injected by get_owned_graph dependency)
    db_session: Database session
    current_user: Authenticated user

Raises:
    HTTPException 404: If the knowledge graph doesn't exist
    HTTPException 403: If you are not the owner
 * @summary Get visualization data for your own knowledge graph
 */
const getMyGraphVisualizationMeGraphsGraphIdVisualizationGet = (
    graphId: string,
 options?: SecondParameter<typeof apiClient<GraphVisualization>>,) => {
      return apiClient<GraphVisualization>(
      {url: `/me/graphs/${graphId}/visualization`, method: 'GET'
    },
      options);
    }
  
/**
 * Get complete content of a knowledge graph including all nodes and relations.

Returns:
    - graph: Basic graph information
    - nodes: All knowledge nodes in the graph
    - prerequisites: All prerequisite relationships

Args:
    knowledge_graph: Owned knowledge graph (injected by get_owned_graph dependency)
    db_session: Database session
    current_user: Authenticated user

Raises:
    HTTPException 404: If the knowledge graph doesn't exist
    HTTPException 403: If you are not the owner
 * @summary Get complete content of a knowledge graph
 */
const getMyGraphContentMeGraphsGraphIdContentGet = (
    graphId: string,
 options?: SecondParameter<typeof apiClient<GraphContentResponse>>,) => {
      return apiClient<GraphContentResponse>(
      {url: `/me/graphs/${graphId}/content`, method: 'GET'
    },
      options);
    }
  
/**
 * Enroll in your own knowledge graph.

This endpoint allows the owner of a knowledge graph to enroll themselves
to start learning from their own graph. This is useful for:
- Testing the learning experience
- Self-study using your own curriculum
- Tracking your own progress

Args:
    knowledge_graph: Owned knowledge graph (injected by get_owned_graph dependency)
    db_session: Database session
    current_user: Authenticated user (must be the graph owner)

Returns:
    GraphEnrollmentResponse: The created enrollment details

Raises:
    HTTPException 404: If the knowledge graph doesn't exist
    HTTPException 403: If the user is not the owner of the knowledge graph
    HTTPException 409: If already enrolled
    HTTPException 500: If database operation fails
 * @summary Enroll in your own knowledge graph
 */
const enrollInGraphMeGraphsGraphIdEnrollmentsPost = (
    graphId: string,
 options?: SecondParameter<typeof apiClient<GraphEnrollmentResponse>>,) => {
      return apiClient<GraphEnrollmentResponse>(
      {url: `/me/graphs/${graphId}/enrollments`, method: 'POST'
    },
      options);
    }
  
/**
 * Upload a file (PDF or Markdown) and automatically generate knowledge nodes.

    **Supported file types**:
    - `.pdf` - PDF files (handwritten or formatted)
    - `.md` - Markdown files

    **Processing flow**:
    - **PDF files**: Extract text ‚Üí Convert to markdown ‚Üí Generate nodes
    - **Markdown files**: Read content ‚Üí Generate nodes directly

    The system will automatically detect the file type and use the appropriate pipeline.
 * @summary Upload file and generate nodes
 */
const uploadFileMeGraphsGraphIdUploadFilePost = (
    graphId: string,
    bodyUploadFileMeGraphsGraphIdUploadFilePost: BodyUploadFileMeGraphsGraphIdUploadFilePost,
 options?: SecondParameter<typeof apiClient<unknown>>,) => {const formData = new FormData();
formData.append(`file`, bodyUploadFileMeGraphsGraphIdUploadFilePost.file)

      return apiClient<unknown>(
      {url: `/me/graphs/${graphId}/upload-file`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData
    },
      options);
    }
  
/**
 * Trigger AI generation of questions for nodes in the knowledge graph.
    This process is asynchronous and may take some time.

    You can control:
    - Number of questions per node
    - Difficulty distribution
    - Question types
    - Whether to skip nodes that already have questions
 * @summary Generate questions for a knowledge graph using AI
 */
const generateQuestionsMeGraphsGraphIdGenerateQuestionsPost = (
    graphId: string,
    generateQuestionsRequest: GenerateQuestionsRequest,
 options?: SecondParameter<typeof apiClient<unknown>>,) => {
      return apiClient<unknown>(
      {url: `/me/graphs/${graphId}/generate-questions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: generateQuestionsRequest
    },
      options);
    }
  
/**
 * Generate prerequisite relationships between nodes using AI.

    This endpoint:
    1. Analyzes all nodes in the graph
    2. Uses AI to determine prerequisite relationships
    3. Validates relationships (no cycles, bad edges, duplicates)
    4. Creates valid prerequisite edges
    5. Updates graph topology (levels, dependent counts)

    The process may take a few minutes depending on graph size.
 * @summary Generate prerequisite relationships for a knowledge graph
 */
const generateRelationsMeGraphsGraphIdGenerateRelationsPost = (
    graphId: string,
 options?: SecondParameter<typeof apiClient<RelationGenerationResponse>>,) => {
      return apiClient<RelationGenerationResponse>(
      {url: `/me/graphs/${graphId}/generate-relations`, method: 'POST'
    },
      options);
    }
  
/**
 * Get all template knowledge graphs available for enrollment.

Template graphs are official curriculum templates that:
- Are marked as templates (is_template=True)
- Are available for authenticated users to enroll in
- Provide standardized learning paths created by administrators

This endpoint requires authentication and returns enrollment status
for each template graph.

Returns:
    list[KnowledgeGraphResponse]: List of all template knowledge graphs,
        ordered by creation date (newest first). Each graph includes:
        - Basic graph information (name, description, tags, etc.)
        - node_count: Number of knowledge nodes in the graph
        - is_enrolled: Whether the current user is enrolled in this graph

Use cases:
- Browsing available official curricula
- Checking enrollment status across all templates
- Selecting a template to enroll in
 * @summary Get all template knowledge graphs
 */
const getTemplateGraphsGraphsTemplatesGet = (
    
 options?: SecondParameter<typeof apiClient<KnowledgeGraphResponse[]>>,) => {
      return apiClient<KnowledgeGraphResponse[]>(
      {url: `/graphs/templates`, method: 'GET'
    },
      options);
    }
  
/**
 * Enroll in a public or template knowledge graph.

This endpoint allows any authenticated user to enroll in knowledge graphs that are:
- Public (is_public=True): Shared by creators for anyone to learn from
- Template (is_template=True): Official curriculum templates

Use cases:
- Students enrolling in published courses
- Users learning from community-shared curricula
- Self-learners accessing template educational content

Args:
    graph_id: Knowledge graph UUID (from URL path)
    db_session: Database session
    current_user: Authenticated user

Returns:
    GraphEnrollmentResponse: The created enrollment details

Raises:
    HTTPException 404: If the knowledge graph doesn't exist
    HTTPException 403: If the graph is neither public nor template
    HTTPException 409: If already enrolled
    HTTPException 500: If database operation fails
 * @summary Enroll in a public or template knowledge graph
 */
const enrollInTemplateGraphGraphsGraphIdEnrollmentsPost = (
    graphId: string,
 options?: SecondParameter<typeof apiClient<GraphEnrollmentResponse>>,) => {
      return apiClient<GraphEnrollmentResponse>(
      {url: `/graphs/${graphId}/enrollments`, method: 'POST'
    },
      options);
    }
  
/**
 * Get detailed information about a public or template knowledge graph.

This endpoint allows authenticated users to view details of:
- Public graphs (is_public=True): Shared by creators
- Template graphs (is_template=True): Official curricula

Returns:
    KnowledgeGraphResponse: Graph details including node count and enrollment status

Raises:
    HTTPException 404: If the knowledge graph doesn't exist
    HTTPException 403: If the graph is neither public nor template (private)
 * @summary Get public or template knowledge graph details
 */
const getTemplateGraphDetailsGraphsGraphIdGet = (
    graphId: string,
 options?: SecondParameter<typeof apiClient<KnowledgeGraphResponse>>,) => {
      return apiClient<KnowledgeGraphResponse>(
      {url: `/graphs/${graphId}/`, method: 'GET'
    },
      options);
    }
  
/**
 * Get the next recommended question for learning in an enrolled public/template graph.

This endpoint:
1. Verifies the graph is public or template
2. Verifies the user is enrolled in the graph
3. Uses the question recommendation algorithm to select the best next node
4. Returns a random question from that node

Args:
    graph_id: Knowledge graph UUID
    db_session: Database session
    current_user: Authenticated user

Returns:
    NextQuestionResponse: The next recommended question with metadata

Raises:
    HTTPException 404: If the knowledge graph doesn't exist
    HTTPException 403: If the graph is private or user is not enrolled
    HTTPException 500: If question selection fails
 * @summary Get the next question in a enrolled knowledge graph
 */
const getNextQuestionInEnrolledGraphGraphsGraphIdNextQuestionGet = (
    graphId: string,
 options?: SecondParameter<typeof apiClient<NextQuestionResponse>>,) => {
      return apiClient<NextQuestionResponse>(
      {url: `/graphs/${graphId}/next-question`, method: 'GET'
    },
      options);
    }
  
/**
 * Get visualization data for a knowledge graph.

Returns all nodes with user mastery scores and prerequisite edges
for rendering a knowledge graph visualization.

Args:
    graph_id: Knowledge graph UUID
    db_session: Database session
    current_user: Authenticated user

Returns:
    GraphVisualization: Graph structure with nodes (including mastery scores) and edges

Raises:
    HTTPException 404: If the knowledge graph doesn't exist
    HTTPException 403: If the graph is private and user is not enrolled/owner
 * @summary Get knowledge graph visualization data
 */
const getGraphVisualizationEndpointGraphsGraphIdVisualizationGet = (
    graphId: string,
 options?: SecondParameter<typeof apiClient<GraphVisualization>>,) => {
      return apiClient<GraphVisualization>(
      {url: `/graphs/${graphId}/visualization`, method: 'GET'
    },
      options);
    }
  
/**
 * Get complete content of a public or template knowledge graph.

Any authenticated user can access content of graphs that are:
- Public (is_public=True)
- Template (is_template=True)

Returns:
    - graph: Basic graph information
    - nodes: All knowledge nodes in the graph
    - prerequisites: All prerequisite relationships

Raises:
    HTTPException 404: If the knowledge graph doesn't exist
    HTTPException 403: If the graph is private
 * @summary Get complete content of a public or template knowledge graph
 */
const getPublicGraphContentGraphsGraphIdContentGet = (
    graphId: string,
 options?: SecondParameter<typeof apiClient<GraphContentResponse>>,) => {
      return apiClient<GraphContentResponse>(
      {url: `/graphs/${graphId}/content`, method: 'GET'
    },
      options);
    }
  
/**
 * Submit a single answer for immediate grading and mastery update.

This endpoint supports practice mode with immediate feedback:
1. Validates the question exists
2. Grades the answer
3. Saves the answer record
4. Updates user's mastery level (including propagation)
5. (Future) Recommends next question

Note: The mastery service handles propagation internally, updating
related nodes in the knowledge graph automatically.

Args:
    answer_data: The answer submission data
    db: Database session
    current_user: Authenticated user

Returns:
    SingleAnswerSubmitResponse with grading result and mastery update status

Raises:
    HTTPException 404: Question not found
    HTTPException 500: Grading or mastery update failed
 * @summary Submit Single Answer
 */
const submitSingleAnswerAnswerPost = (
    singleAnswerSubmitRequest: SingleAnswerSubmitRequest,
 options?: SecondParameter<typeof apiClient<SingleAnswerSubmitResponse>>,) => {
      return apiClient<SingleAnswerSubmitResponse>(
      {url: `/answer`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: singleAnswerSubmitRequest
    },
      options);
    }
  
/**
 * @summary Health Check
 */
const healthCheckHealthGet = (
    
 options?: SecondParameter<typeof apiClient<unknown>>,) => {
      return apiClient<unknown>(
      {url: `/health`, method: 'GET'
    },
      options);
    }
  
/**
 * @summary Root
 */
const rootGet = (
    
 options?: SecondParameter<typeof apiClient<unknown>>,) => {
      return apiClient<unknown>(
      {url: `/`, method: 'GET'
    },
      options);
    }
  
return {readUsersMeUsersMeGet,getNextQuestionMeGraphsGraphIdNextQuestionGet,createKnowledgeNodeNewMeGraphsGraphIdNodesPost,createPrerequisiteNewMeGraphsGraphIdPrerequisitesPost,createQuestionNewMeGraphsGraphIdQuestionsPost,getMyGraphsMeGraphsGet,createGraphMeGraphsPost,getMyGraphMeGraphsGraphIdGet,getMyGraphVisualizationMeGraphsGraphIdVisualizationGet,getMyGraphContentMeGraphsGraphIdContentGet,enrollInGraphMeGraphsGraphIdEnrollmentsPost,uploadFileMeGraphsGraphIdUploadFilePost,generateQuestionsMeGraphsGraphIdGenerateQuestionsPost,generateRelationsMeGraphsGraphIdGenerateRelationsPost,getTemplateGraphsGraphsTemplatesGet,enrollInTemplateGraphGraphsGraphIdEnrollmentsPost,getTemplateGraphDetailsGraphsGraphIdGet,getNextQuestionInEnrolledGraphGraphsGraphIdNextQuestionGet,getGraphVisualizationEndpointGraphsGraphIdVisualizationGet,getPublicGraphContentGraphsGraphIdContentGet,submitSingleAnswerAnswerPost,healthCheckHealthGet,rootGet}};
export type ReadUsersMeUsersMeGetResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getFastAPI>['readUsersMeUsersMeGet']>>>
export type GetNextQuestionMeGraphsGraphIdNextQuestionGetResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getFastAPI>['getNextQuestionMeGraphsGraphIdNextQuestionGet']>>>
export type CreateKnowledgeNodeNewMeGraphsGraphIdNodesPostResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getFastAPI>['createKnowledgeNodeNewMeGraphsGraphIdNodesPost']>>>
export type CreatePrerequisiteNewMeGraphsGraphIdPrerequisitesPostResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getFastAPI>['createPrerequisiteNewMeGraphsGraphIdPrerequisitesPost']>>>
export type CreateQuestionNewMeGraphsGraphIdQuestionsPostResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getFastAPI>['createQuestionNewMeGraphsGraphIdQuestionsPost']>>>
export type GetMyGraphsMeGraphsGetResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getFastAPI>['getMyGraphsMeGraphsGet']>>>
export type CreateGraphMeGraphsPostResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getFastAPI>['createGraphMeGraphsPost']>>>
export type GetMyGraphMeGraphsGraphIdGetResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getFastAPI>['getMyGraphMeGraphsGraphIdGet']>>>
export type GetMyGraphVisualizationMeGraphsGraphIdVisualizationGetResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getFastAPI>['getMyGraphVisualizationMeGraphsGraphIdVisualizationGet']>>>
export type GetMyGraphContentMeGraphsGraphIdContentGetResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getFastAPI>['getMyGraphContentMeGraphsGraphIdContentGet']>>>
export type EnrollInGraphMeGraphsGraphIdEnrollmentsPostResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getFastAPI>['enrollInGraphMeGraphsGraphIdEnrollmentsPost']>>>
export type UploadFileMeGraphsGraphIdUploadFilePostResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getFastAPI>['uploadFileMeGraphsGraphIdUploadFilePost']>>>
export type GenerateQuestionsMeGraphsGraphIdGenerateQuestionsPostResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getFastAPI>['generateQuestionsMeGraphsGraphIdGenerateQuestionsPost']>>>
export type GenerateRelationsMeGraphsGraphIdGenerateRelationsPostResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getFastAPI>['generateRelationsMeGraphsGraphIdGenerateRelationsPost']>>>
export type GetTemplateGraphsGraphsTemplatesGetResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getFastAPI>['getTemplateGraphsGraphsTemplatesGet']>>>
export type EnrollInTemplateGraphGraphsGraphIdEnrollmentsPostResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getFastAPI>['enrollInTemplateGraphGraphsGraphIdEnrollmentsPost']>>>
export type GetTemplateGraphDetailsGraphsGraphIdGetResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getFastAPI>['getTemplateGraphDetailsGraphsGraphIdGet']>>>
export type GetNextQuestionInEnrolledGraphGraphsGraphIdNextQuestionGetResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getFastAPI>['getNextQuestionInEnrolledGraphGraphsGraphIdNextQuestionGet']>>>
export type GetGraphVisualizationEndpointGraphsGraphIdVisualizationGetResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getFastAPI>['getGraphVisualizationEndpointGraphsGraphIdVisualizationGet']>>>
export type GetPublicGraphContentGraphsGraphIdContentGetResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getFastAPI>['getPublicGraphContentGraphsGraphIdContentGet']>>>
export type SubmitSingleAnswerAnswerPostResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getFastAPI>['submitSingleAnswerAnswerPost']>>>
export type HealthCheckHealthGetResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getFastAPI>['healthCheckHealthGet']>>>
export type RootGetResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getFastAPI>['rootGet']>>>
